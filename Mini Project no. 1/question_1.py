# -*- coding: utf-8 -*-
"""Question_1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12kHtTlODCUSPSautUmzXWJlpgz0Kz6iO
"""

!mkdir -p ~/.kaggle
!cp ../kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download -d "sakshigoyal7/credit-card-customers"
!unzip credit-card-customers.zip

import pandas as pd

data = pd.read_csv('BankChurners.csv')
print(data.columns)

data.drop(columns=['Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2',
                   'Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1'],
          inplace=True, errors='ignore')

print(data.columns)

data.head()

from sklearn.preprocessing import LabelEncoder

replace_mappings = {
    'Gender': {'M': 1, 'F': 0},
    'Attrition_Flag': {'Existing Customer': 0, 'Attrited Customer': 1},
    'Education_Level': {
        'Unknown': 0, 'Uneducated': 1, 'High School': 2,
        'College': 3, 'Graduate': 4, 'Post-Graduate': 5, 'Doctorate': 6
    }
}

for column, mapping in replace_mappings.items():
    data[column] = data[column].replace(mapping)

columns_to_encode = ['Marital_Status', 'Income_Category', 'Card_Category']
label_encoder = LabelEncoder()

for column in columns_to_encode:
    data[column] = label_encoder.fit_transform(data[column])

data.info()

import seaborn as sns
sns.pairplot(data[['Attrition_Flag', 'Customer_Age', 'Education_Level', 'Income_Category', 'Total_Trans_Ct']])

import seaborn as sns
import matplotlib.pyplot as plt

correlation = data[['Attrition_Flag', 'Gender', 'Education_Level', 'Income_Category', 'Total_Trans_Ct']].corr()
sns.heatmap(correlation, annot=True, cmap='coolwarm', fmt=".4f")

data.info()

data.isnull().values.any()

import matplotlib.pyplot as plt
category_counts = data['Attrition_Flag'].value_counts()
plt.figure(figsize=(8, 6))
plt.pie(
    category_counts,
    labels=category_counts.index,
    autopct='%1.1f%%',
    startangle=90,
    colors=['skyblue', 'lightcoral'],
    explode=[0.1, 0]
)
plt.title('Distribution of Attrition Flag', fontsize=14)
plt.show()

from sklearn.model_selection import train_test_split

Y = data.iloc[:, 1]
X = data.drop(columns=data.columns[1])

Y

X

indices = Y.index

train_indices, test_indices = train_test_split(indices, test_size=0.2, stratify=Y, random_state=93)
X_train, Y_train = X.loc[train_indices], Y.loc[train_indices]
X_test, Y_test = X.loc[test_indices], Y.loc[test_indices]

test_indices, val_indices = train_test_split(test_indices, test_size=0.25, random_state=93)
X_test, Y_test = X.loc[test_indices], Y.loc[test_indices]
X_val, Y_val = X.loc[val_indices], Y.loc[val_indices]

len(X_test)

len(X_val)

from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score
import warnings
warnings.filterwarnings("ignore")

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_val_scaled = scaler.transform(X_val)
X_test_scaled = scaler.transform(X_test)

param_grid = {
    'penalty': ['l1', 'l2', 'elasticnet'],
    'C': [0.01, 0.1, 1, 10, 100],
    'solver': ['liblinear', 'saga'],
    'tol': [1e-3, 1e-4, 1e-5],
    'class_weight': ['balanced', None],
}

grid_search = GridSearchCV(LogisticRegression(max_iter=2000, random_state=93), param_grid, cv=5, n_jobs=-1)
grid_search.fit(X_train_scaled, Y_train)
best_model = grid_search.best_estimator_

Y_pred = best_model.predict(X_test_scaled)
Y_val_pred = best_model.predict(X_val_scaled)

print(f"Best Parameters: {grid_search.best_params_}")

print(best_model)

from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

cm_test = confusion_matrix(Y_test, Y_pred)
cm_val = confusion_matrix(Y_val, Y_val_pred)

plt.figure(figsize=(8, 6))
sns.heatmap(cm_test, annot=True, fmt="d", cmap="Blues", xticklabels=['Predicted Negative', 'Predicted Positive'], yticklabels=['Actual Negative', 'Actual Positive'])
plt.title('Confusion Matrix (Test)')
plt.ylabel('True Label')
plt.xlabel('Predicted Label')
plt.show()

plt.figure(figsize=(8, 6))
sns.heatmap(cm_val, annot=True, fmt="d", cmap="Blues", xticklabels=['Predicted Negative', 'Predicted Positive'], yticklabels=['Actual Negative', 'Actual Positive'])
plt.title('Confusion Matrix (Validation)')
plt.ylabel('True Label')
plt.xlabel('Predicted Label')
plt.show()

from sklearn.metrics import precision_score, recall_score, balanced_accuracy_score, f1_score

precision_test = precision_score(Y_test, Y_pred)
recall_test = recall_score(Y_test, Y_pred)
balanced_accuracy_test = balanced_accuracy_score(Y_test, Y_pred)
f1 = f1_score(Y_test, Y_pred, average='weighted')

precision_val = precision_score(Y_val, Y_val_pred)
recall_val = recall_score(Y_val, Y_val_pred)
balanced_accuracy_val = balanced_accuracy_score(Y_val, Y_val_pred)
f2 = f1_score(Y_val, Y_val_pred, average='weighted')

print(f"F1 Score test: {f1:.2f}")
print(f"Precision Test: {precision_test}")
print(f"Recall Test: {recall_test}")
print(f"Balanced Accuracy Test: {balanced_accuracy_test}")
print(f"F1 Score Validation: {f2:.2f}")
print(f"Precision Validation: {precision_val}")
print(f"Recall Validation: {recall_val}")
print(f"Balanced Accuracy Validation: {balanced_accuracy_val}")

from imblearn.over_sampling import SMOTE
from sklearn.metrics import classification_report

smote = SMOTE(random_state=93)
X_train_balanced, Y_train_balanced = smote.fit_resample(X_train, Y_train)
X_train_balanced_scaled = scaler.fit_transform(X_train_balanced)

grid_search_balanced = GridSearchCV(LogisticRegression(max_iter=2000, random_state=93), param_grid, cv=5, n_jobs=-1)
grid_search_balanced.fit(X_train_balanced_scaled, Y_train_balanced)
best_model_balanced = grid_search_balanced.best_estimator_

Y_pred_balanced = best_model_balanced.predict(X_test_scaled)
Y_val_pred_balanced = best_model_balanced.predict(X_val_scaled)

print(f"Best Parameters (Balanced Data): {grid_search_balanced.best_params_}")

cm_test_balanced = confusion_matrix(Y_test, Y_pred_balanced)
cm_val_balanced = confusion_matrix(Y_val, Y_val_pred_balanced)

plt.figure(figsize=(8, 6))
sns.heatmap(cm_test_balanced, annot=True, fmt="d", cmap="Greens", xticklabels=['Predicted Negative', 'Predicted Positive'], yticklabels=['Actual Negative', 'Actual Positive'])
plt.title('Confusion Matrix (Test - Balanced)')
plt.ylabel('True Label')
plt.xlabel('Predicted Label')
plt.show()

plt.figure(figsize=(8, 6))
sns.heatmap(cm_val_balanced, annot=True, fmt="d", cmap="Greens", xticklabels=['Predicted Negative', 'Predicted Positive'], yticklabels=['Actual Negative', 'Actual Positive'])
plt.title('Confusion Matrix (Validation - Balanced)')
plt.ylabel('True Label')
plt.xlabel('Predicted Label')
plt.show()

print("Classification Report (Test - Original Data):")
print(classification_report(Y_test, Y_pred))
print("\nClassification Report (Test - Balanced Data):")
print(classification_report(Y_test, Y_pred_balanced))

import seaborn as sns
import matplotlib.pyplot as plt

columns_to_plot = ['Attrition_Flag', 'Customer_Age', 'Education_Level', 'Income_Category', 'Total_Trans_Ct']
data_plot = data.copy()
data_plot['Attrition_Flag'] = Y

sns.pairplot(data=data_plot[columns_to_plot], hue='Attrition_Flag', diag_kind='kde', palette='Set2')
plt.gcf().set_size_inches(15, 15)
plt.show()